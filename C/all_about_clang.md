# c언어의 모든것(복습)


### 포인터 변수 : 주소를 저장하고 그 주소를 가리킬 수 있는 변수  

- int *, char *, float * 등이 포인터 자료형이다.  
--> 포인터의 메모리 크기는 모두9 4byte(주소 저장을 위해), 포인터 자료형의 int, char,,,, 들은 모두 포인터가 가리키는 메모리 주소에서 몇바이트만큼을 읽어들여 해석해야하는지를 정해준다.

- 선언 시 자료형을 지정해야한다   
     --> 가리키는 주소에서 얼마만큼 읽어야하는지 모르기 때문에  
     ==> 포인터 변수가 int형이라면 p++은 주소 4만큼 증가이다.  
- 배열 이름은 배열의 시작 주소를 가리키기 때문에 포인터와 동일한 원리로 사용가능 ==> p++ == p[1] == 배열[1]  
배열 이름은 포인터 상수이다 (상수 포인터와 포인터 상수에는 엄연한 차이점이 있다.)
  

### 문자열
1.  문자열 저장법  
    * char형 배열 사용  
    > 일일이 대입 : 끝부분에 NULL문자를 수동으로 추가해야함  
    문자열 상수 사용 : 자동으로 문자열의 끝에 NULL문자 추가  
    라이브러리 함수 사용  
    * 문자형 포인터 사용
    > 문자열 상수의 주소를 대입하면 된다.  

        char *p = "hihi"; //문자형 포인터에 문자열 상수의 주소 대입

        p = "byebye"; //포인터의 주소를 변경하여 문자열 변경 가능

2. 문자열 상수  
텍스트 세그먼트라는 접근만 가능한 메모리 공간에 저장한다.  
문자형 포인터에 저장된 문자열 상수는 직접 변경 불가능함
    * (참고: 모든 변수는 데이터 세그먼트라고 불리는 메모리 영역에 저장)   

    ***(중요)컴파일러가 문자열 상수를 만나면 해당 문자열을 텍스트 세그먼트에 저장하고, 그 텍스트 세그먼트의 메모리 주소를 반환한다.


3. 문자열 배열  
문자열을 저장하기 위해선 NULL문자를 포함한 크기로 선언해야한다.



4. 문자 입출력 라이브러리 함수  
* echo : 문자를 입력하면 화면에도 출력  
 * buffer : 문자를 입력받는대로 buffer에 저장후 '\n'이 입력되면 프로그램으로 전달  

        <stdio.h>  
        int getchar(void) //하나의 문자를 읽어서 반환한다, 에코 사용, 버퍼 사용
        void putchar(int) //인수를 화면에 출력
        scanf("%c")
        printf("%c")


        <conio.h>     
        int _getch() //에코 사용하지 않음, 버퍼 사용하지 않음
        int _getch() //에코 사용, 버퍼 사용하지 않음
        void _putch(int) //인수를 화면에 출력

5. 문자 처리 라이브러리 함수  
<ctype.h>  
기본적으로 참과 거짓을 검사하는 함수이다.  
반환값은 1 또는 0으로 이루어진다.
  
6. 문자열 입출력 라이브러리 함수  


        <stdio.h>
        int scanf("%s", s) //문자열을 배열 s에 저장
        int printf("%s", s) //배열 s의 문자열을 출력(\0이 나올때까지)

        char *gets_s(char *s, int size) 
        //'\n'이 나올 때까지 문자열로 입력받는다. 줄바꿈 문자는 포함되지 않으며 끝에는 \0이 붙는다. 
        //반환값은 성공하면 인수 배열이 그대로 반환되고 실패하면 NULL값이 반환된다.

        int puts(const char *s) 
        //배열 s에 저장된 문자열 출력
        //배열 끝의 NULL문자는 \n으로 자동 변환
        //반환값은 성공하면 음수가 아닌 값이 반환되고 실패하면 EOF가 반환된다.

            <예시>
            char buff[100];
            gets_s(buff, 100);
            puts(buff);

7. 문자열 처리 라이브러리 함수  

        <string.h>

* 문자열 길이  

        strlen(s)  
    >문자열 s의 길이를 구한다 .  

* 문자열 복사  

        strcpy(s1, s2)  
    > s2가 가리키는 문자열을 s1이 가리키는 배열로 복사한다.  
    덮어씌워져서 기존의 문자열은 없어진다.  
    \0문자가 나올 때까지 복사를 계속한다.  
    복사하는 문자열의 크기보다 배열의 크기가 같거나 커야한다.

        <예시>
        char s1[10];
        char s2[10] = "hihihi";
        strcpy(s1, s2);

* 문자열 연결  

        strcat(s1, s2)  
    > s1 뒤에 문자열 s2를 붙인다. 그리고 NULL문자로 종료

* 문자열 비교  

        strcmp(s1, s2)  
    > 사전적인 순서로 두개의 문자열 비교  
    >   > s1이 s2보다 앞에 있다면    반환값<0  
    >   > s1 == s2  반환값 = 0  
    >   > s1이 s2뒤에 있으면 반환값 > 0

* 문자 n개 까지만 문자열 처리하기
    
        strncpy, strncat, strncmp(s1, s2, n)
    
    > 각각 문자 n개 까지 문자열을 처리한다.


* 문자검색  

        char *p = strchr("문자열", '문자');

    >문자열에서 발견된 문자의 주소를 반환함  
    찾지 못하면 NULL값 반환

        <예시>
        char[s] = "language";
        char c = 'g';
        char *p;
        int loc;

        p = strchr(s, c);
        log = (int)(p-s) 
        //g의 주소에서 s의 시작 주소를 뺀다 ==> g가 몇번째에 있는지 구한다.
        //배열 한칸은 1바이트이므로 p-s를 빼면 몇번째인지 나온다. (int형 배열이었다면 4byte정도 나왔을것임)
        //int 자료형 변환 이유는 출력하기 위해 정수형으로 변환한 것이다.

* 문자열 검색

        char *p = strstr("문자열", '문자');

    >문자열에서 발견된 문자열의 시작 주소를 반환함  
    찾지 못하면 NULL값 반환

    
8. 문자열 여러개 저장

* 포인터 배열 사용  

        char *p[3] = {"~~", "~~", "~~"};

    >--> 메모리 낭비를 줄이면서 문자열 여러개 저장 가능  
    >--> 텍스트 세그먼트에 저장되므로 변경 불가능

* 이차원 배열 사용

        char s[3][10] = {"~~","~~","~~"};

    > 문자형 배열에 문자열을 저장하듯이 문자열의 크기만큼 배열에 저장됨
    > 각 문자열의 마지막에는 NULL값 저장

### 구조체  


1. 기본 규칙  (파생형 자료형의 기본 규칙으로 봐도 무방)
    > 정의된 구조체 자료형은 다른 자료형과 동일하게 취급 
    >   > struct 태그 --> 하나의 자료형으로써 컴파일러는 struct 키워드를 보고 구조체임을 알고, 태그를 확인함으로써 어떤 구조체인지 확인하여 메모리 사용.  
    >   > 따라서 태그를 사용하지 않고 구조체를 정의한다면 동시에 변수도 선언을 할 수 밖에 없는 것이다.

    > 구조체 변수는 일반적인 변수와 동일하게 취급.  
    > 구조체 멤버에는 모든 자료형이 가능하다.  



### 공용체

1. 기본규칙   
    > 구조체와 규칙이 같다 .  
    메모리 할당은 멤버 중 크기가 가장 큰 멤버를 기준으로 할당된다.  
    멤버 접근은 구조체와 동일하게 (.)멤버연산자를 사용한다.  
    데이터 저장은 한번에 하나의 멤버에게만 가능하다.

2. 초기화

        union 태그명 변수명 = {~}; //첫번째 멤버에게만 값이 저장된다.  

### 열거형

1. 가독성과 의미해석이 더 수월해져 오류의 가능성이 줄어든다.
    > ex) 요일을 0~6의 숫자에 맵핑해서 사용해왔다면 열거형을 통해 기호상수로 불편함 해소


2. 사용법  
        정의

        enum days {SUN, MON, TUE, WED, THU, SAT};
        //열거형은 기호상수가 모여있는 자료형이다.
        //왼쪽부터 오른쪽으로, 0부터 1씩 증가하며, 맵핑하여 각각의 단어를 기호상수로 만들어준다.   

        enum days {SUN = 2, MON, TUE=5, WED};
        //기호상수이므로 직접 숫자를 맵핑해줄 수도 있다.
        //직접 맵핑된 기호상수 옆엔 맵핑되지 않았을 경우 자동으로 왼쪽의 것보다 +1된 것으로 간주함 (여기서 MON은 3이다.)

    열거형 변수 사용은 동일하다.


### typedef 사용자 정의 자료형

1. 사용방법

        typedef 자료형 새로운자료형;
        


        //구조체, 공용체, 열거형 정의 또한 자료형으로 간주하므로 아래와 같이 코드 구성 가능
        //태그 생략도 가능하다.

        //구조체
        typedef struct 태그{
            //멤버
        }새로운 자료형;

        //공용체
        typedef union 태그{
            //멤버
        }새로운 자료형;
        
        //열거형
        typedef enum 태그 {기호상수} 새로운 자료형;

2. 배열을 새로운 자료형으로 정의할 때

        typedef int intarray[3];
        intarray a;
        //a는 int형 3개가 들어갈 수 있는 자료형으로써 정의된다. (a[3]으로 선언된 것과 똑같다.)

3. 장점  
    1. 이식성을 높여준다.  
    2. #define 보다 좋다.  
    > #define은 전처리가 처리하므로 배열 같은 자료형은 정의하지 못한다.  
    > typedef는 컴파일러가 처리하므로 자료형 정의에 있어서 더 좋다.  
    3. 문서화의 역할도 한다.


### 포인터 활용  
1. 이중 포인터
        
        int i = 100;
        int *p =&i;
        int **q = &p;
        //연산자 우선순위를 통해 해석하기

2. 포인터 배열     
    자료형이 포인터(int *, char * ...등)인 배열이다.

        int *ap[10];

* 래그드 배열  
    문자열 여러개를 저장할 때, 메모리의 낭비를 최소화하기 위해 텍스트 세그먼트에 저장된 문자열 상수를 이용한다.  
    (텍스트 세그먼트의 주소를 이용하므로 문자열의 수정 불가능, 직접 주소를 바꿔야함)

3. 배열 포인터
        
        int (*ap)[5]; //연산자 우선순위에 의해 해석하면 int [5]에 대한 포인터이다.

        //포인터를 통해 주소를 참조할 때, Int [5]만큼을 참조한다.
        int a[5];
        ap = &a; 




4. 함수 포인터  
    - 포인터 자료형과 함께 반환형, 매개 변수를 함께 선언하면 함수 포인터로써 사용가능하다.
    - 함수 또한 메모리에 저장되므로 함수의 시작 위치의 주소를 참조하면 함수 호출이 가능하다.


            int (*pf)(int, int); //연산자 우선순위에 의해 괄호를 붙여야 한다.


            <ex>
            int (*pf)(int, int); //함수 포인터 선언
            int plus(int, int); 
            ...
            pf = sub; //함수의 주소를 포인터에 저장
            ...

            pf(1,3); //함수 호출



* (번외)함수 포인터의 배열  
    자료형이 함수(?)인 포인터 배열도 가능하다.

        int (*pf[5])(int, int);

* 함수 포인터를 인수로 전달하기  
    함수안의 함수가 가변적일 때,(수학 수식에서 g(f(x)) = f(x) + 1) 함수 포인터를 사용하여 매개변수로 받는다.(void 포인터 참고)  

    
        반환형 f(매개변수, 매개변수);

        int g(int (*pf)()){ //함수를 매개변수로 받을 때, 반환형은 필요하지만 매개변수는 가변적으로 할당된다.
            ...
        }

        int main(){
            g(f)
        }


5. void 포인터  
    제네릭 포인터라고도 하며 순수한 메모리 주소만을 저장하는 포인터이다.

        void *p; //void 포인터 선언
        

    void포인터는 모든 자료형을 유연하게 참조할 수 있으며 참조할 때는 형변환을 해야한다.
        
        int a = 10;
        p = &a;

        *(int *)p; //변수 a 참조

6. const, volatile 포인터

* const  
        
        const char *p; // p가 가리키는 내용이 변경되지 않는다 --> p가 저장하는 주소는 변경 가능

        char * const p; //p가 저장하는 주소는 변경할 수 없다. --> p가 가리키는 내용은 변경 가능

* volatile  
    해당 포인터의 값을 사용할때 마다 매번 메모리에서 직접 읽는다.(레지스터와 같은 임시 저장장치에서 로드 불가능 --> 해당 값에 대하여 최적화를 못하게 한다.)


7. main 함수의 인수

        int main(int argc, char *argv){
            ...
        }

    // 명령 줄 인터페이스를 통해 실행할 때 //  
    argc(argument count) : 커맨드 라인에 존재하는 모든 단어들의 개수를 전달한다.(실행하기 위해 작성한 프로그램의 경로도 포함된다.)   
      
    argv(argument vector) : 커맨드 라인에 있는 문자열 상수의 주소를 문자형 포인터 배열에 저장한다.





### 다차원 배열을 포인터로 접근  

    int m[3][3]이 있다고 하자


1. 다차원 배열의 메모리 구조  
    메모리는 선형 구조이므로 C언어에서는 행우선 방식을 사용한다.
    > m[0][0] m[0][1] m[0][2] m[1][0] m[1][1] m[1][2] ...  


  


2. 다차원 배열과 포인터 상수의 관계  
            
        m, m[0], m[1], m[2]는 각각 시작주소를 의미한다.

        m //다차원 배열의 전체 시작주소
        m[0] // 배열안의 배열, 즉 m[0][0] m[0][1] .. 인 배열의 시작주소
        m[1] // 위와 동일
        m[2] // 위와 동일

        ...

3. 다차원 배열을 포인터로 접근하는 것은 이중포인터와 관련이 있다.  

        *(m+1) //m[1]이라는 배열을 참조한다. m[1]은 m[1]배열의 시작 주소이므로 해당 값을 출력하면 주소가 나온다.

        **(m+1) //*m[1]과 동일. m[1]이라는 배열의 이름 주소에 참조한다.

        *(m+1)[0] //위와 동일. m[1][0]으로 해석할 수 있음.

        **m+1 // "m[0][0]의 요소를 참조해서 해당 요소를 +1하라" 라고 해석할 수 있음


4. 배열 포인터를 사용하여 요소에 접근하는 방법도 있다.  (잘 모름)
    (공부한 링크 첨부)https://wonit.tistory.com/527  
    (포인터 배열이 아니라는 것에 주의!!)


### 스트림

1. 스트림 개념  
스트림 : 모든 입출력 데이터의 흐름을 바이트들의 흐름으로 생각
특징 : 기본적으로 버퍼를 사용한다.  
장점 : 키보드, 모니터까지도 파일과 프로그램의 입출력 흐름으로 생각하여 편리하다.(장치독립성)  
> - 프로그램에서 입력을 받을땐, 키보드라는 파일에서 데이터를 읽어온다.  
> - 프로그램에서 출력할 땐, 모니터라는 파일에 데이터를 쓴다.  

2. 표준스트림  
- 컴퓨터 프로그램과 단말기 사이에 미리 연결된 입출력 통로.  
- 프로그램이 시작되면 자동으로 연결 통로가 생성된다.
- 보통 입출력은 물리적으로 연결된 키보드와 모니터를 통해 일어나는데 이것을 추상화한 것.    
배경 : 과거엔 입출력 장치가 무엇이냐에 따라 다르게 연결해야했음, 이후 데이터 스트림이라는 개념으로 장치의 추상화를 이끌어냄. 그리고 표준 연결 스트림이라는 입출력 장치에 자동으로 연결하는 스트림을 기본으로 제공

        stdin //표준 입력 스트림, 키보드와의 연결통로
        stdout //표준 출력 스트림, 모니터와 연결 통로
        stderr //표준 오류 스트림, 모니터와 연결통로  

### 입출력 함수

1. 입출력함수의 분류

|형식\스트림|표준 스트림|일반 스트림|설명|  
|:------|-----|-----|:----------:|  
|형식이 없는 입출력|getchar()|fgetc(FILE *f, ...)|문자입력함수|
||putchar()|fputc(FILE *f, ...)|문자출력함수|
||gets_s()|fgets(FILE *f, ...)|문자열입력함수|
||puts()|fputs(FILE *f, ...)|문자열출력함수|
|형식이 있는 입출력|printf()|fprintf(FILE *f, ...)|형식화된 출력 함수|
||scanf()|fscanf(FILE *f, ...)|형식화된 입력 함수

> __"형식화된"의 의미__  
printf --> 정수, 실수 등의 데이터를 문자열로 변환하여 출력  
scanf --> 문자열을 입력받아 형식에 맞게 변환  
<u>즉 , "형식화된"이란 printf, scanf와 같이 데이터와 문자열사이의 변환을 해주는 함수들의 의미라고 생각하면 된다.</u>


2. printf
* 형식 제어 문자열  
    플래그, 필드폭, 정밀도, 형식 모두 구글링하여 그때그때 찾기


3. scanf  
문자열을 입력받음으로 문자들을 모아서 형식에 맞게 변환해준다.

    자세한 형식은 구글링하기

    반환값은 읽어들인 항목의 개수이다.


### 파일 입출력

1. 파일 기초  
* 파일도 일련의 연속된 바이트이므로 파일 스트림을 직접 생성해야한다.  
* 모든 파일은 파일 포인터를 가지고 있고, 처음 열면 첫 번째 바이트를 가리킨다. 입출력 연산 이후 자동으로 이동한다.
* 파일의 유형  
    텍스트 파일 : 연속적인 줄로 구성, 각 줄은 줄의 끝을 알리는 문자로 종료(c언어는 \n)  
    이진 파일 : 줄 단위x


2. 파일 열기, 닫기, 삭제  



* 파일열기  
fopen : 파일 이름을 가지고 생성하여 FILE포인터를 반환한다. __실패할 시 NULL포인터가 반환__
            
            FILE *fp;
            fp = fopen("파일이름", "파일모드");

* 파일 닫기  
fclose : 파일포인터가 가리키는 파일을 닫는다. __성공할 시 0 반환, 실패할 시 -1반환__

            fclose(fp);

* 파일 삭제  
remove : __성공할 시 0 반환, 실패한 경우 -1 반환.__

        remove("삭제할 파일 이름")

* 기타 유용한 함수들

        int foef(FILE *stream) //파일의 킅이 도달되면 true를 반환

        int rename(const char *oldname, const char *newname) //파일이름 변경

        int *tmpfile() //임시 파일을 생성하여 주소 반환

3. 텍스트 파일 읽기, 쓰기  


        <stdio.h>
* 문자단위 입출력  

        문자입력
        int fgetc(FILE *fp) 
        //읽은 문자를 정수형으로 반환, 파일의 끝일시 EOF반환


        문자출력
        int fputc(int c, FILE *fp) 
        //문자를 정수형으로 인수전달

* 문자열 단위 입출력

        입력 함수 원형
        char *fgets(char *s, int n, FILE *fp)
        //buffer배열을 인수로 입력받아 n길이 만큼 읽어들인다.

        int fputs(char *s, FILE *fp)
        //buffer배열의 문자열을 파일에 출력한다.


        <예시>
        ...
        while( fgets(buffer, 100, fp1) != NULL)
            fputs(buffer, fp2);

        ...


* 형식화된 입출력   

        int fprinf(FILE *fp, const char *format, ...)
        //...의 데이터를 format을 미리 알려준 후 문자열로 변환하여 파일에 출력

        int fscanf(FILE *fp, const char *format, ...)
        //파일에서 format대로 문자열을 입력받은 후 format에서 알려준 형식대로 변환하여 ...에 입력



4. 이진파일 입출력  
//나중에 공부(중요해보임)

5. 임의접근

* 위치표시자를 조작하는 함수  


        int fseek(FILE *fp, long offset, int origin)
        /*
        offset : 위치 표시자가 이동하는 거리, 양수이면 앞으로 가고 음수이면 뒤로 간다.(바이트 단위이다.)
        origin : 위치 표시자를 이동시키는 기준위치(시작위치)
        */

> origin 상수 값  
SEEK_SET : 0 (파일의 시작)  
SEEK_CUR : 1 (현재 위치)
SEEK_END : 2 (파일의 끝) //EOF가 놓인 위치를 가리킨다.


* 위치 표시자의 현재 위치

        long ftell(FILE *fp)
        //현재 위치 표시자의 값을 long형으로 반환한다.(파일의 크기가 매우 클 경우를 대비하여 long으로 처리)

* 파일의 끝을 알아내는 함수

        int feof(FILE *fp)
        //현재 위치 표시자의 값이 파일의 끝인지를 알려준다.  
        (이진파일인 경우 -1, eof가 파일의 끝을 알려주지 않기 때문에 사용한다.)


### 전처리기  

> 전처리기는 보통 컴파일러에 포함되어 있고 자동으로 실행된다.  

> 소스파일을 처리하여 수정된 소스파일을 생산 --> 수정된 소스 파일을 가지고 본격적으로 컴파일한다.  

1. __#define__  

> 원리 : 소스파일의 어떤 텍스트든지 기호 상수로 치환한다. --> 전처리기는 이를 역으로 치환하여 수정된 소스파일을 생산. __기계적으로 치환한다는 것에 포인트__<u>(x++를 함수 매크로 인수로 넣으면 ++연산이 되지 않고 그대로 x++가 인수로 치환된다.)</u>

* 단순 매크로  
    소스 파일상의 숫자 상수를 기호 상수로 치환하여 값 변경의 용이함과 가독성을 올린다.  


* 함수 매크로  
        
        (ex)
        #define PLUS(x) ((x)+(x))

        PLUS(3) ==> ((3)+(3))으로 대치


    소스 파일상의 텍스트를 대치하는 것은 동일하나 인수가 들어간다.  
    * 어떠한 자료형에 대해서도 가능하다.
    * 변수를 포함한 수식도 매크로의 인수가 될 수 있다.   
    ==> 무엇이든지 인수가 될 수 있다.
    * 두개 이상의 매개 변수를 가질 수 있다.   


    주의사항   
    * 매크로를 정의할 때 사용한 매개 변수는 모두 사용되어야 한다.
    * 매크로 이름과 괄호 사이에 공백이 있으면 안된다.(#define ADD (x, y) --> 오류)  
    * 괄호에 주의하자(기계적 치환에 의해 연산이 뜻대로 되지 않을 수 있다.)  
    * '\'역슬래시를 사용하면 매크로 정의에서 한 줄을 연장할 수 있다.  
    
    매크로 장단점
    * 속도가 빠르다.
    * 매크로의 코드 길이가 길어질 수록 수정된 소스파일이 복잡해진다. (모든 매크로가 해당 코드로 치환되기 때문에)
  
* 문자열 변환 연산자 #  
    > 매크로 정의에서 매개변수 앞에 #이 위치하면 실제 인수는 큰따옴표로 감싸지고, 문자열로 변환된다.

        #define PRINT(exp) printf(#exp" = %d", exp);

        PRINT(x) ==> printf("x = %d", x); 로 치환

2. __조건부 컴파일__
> 컴파일을 제어할 때 사용한다.

>어떤 조건이 만족되는 경우에만 지정된 소스 코드 블록을 컴파일한다.

* #ifdef, #endif, #ifndef, #undef  

    *#ifdef, #endif, #ifndef

        #ifdef DEBUG    
            printf("value = %d\n", value);
        #endif 
        //해당 매크로가 정의되어 있으면 #indef~#endif까지의 코드를 컴파일한다.


        #ifndef //해당 매크로가 정의되어 있지 않으면 #ifndef ~ #endif 사이의 코드를 컴파일한다.

    * #undef  

           #undef SIZE //SIZE매크로의 정의를 취소한다.

* #if, #else, #elif, #endif  
매크로의 값에 따라서 컴파일 여부를 결정한다.  
    * 비교연산자, 사칙연산, 논리연산자 사용가능하다.
    * 매크로끼리의 비교도 가능하다.  

        
            (ex)
            #define NATION 1
            
            #if NATION == 1
                printf("안녕하세요");
            #elif NATION == 2
                printf("hello");
            #else
                printf("~~");
            #endif

* defined()  
괄호 안의 매크로가 정의되어있는지를 확인한다.(조건부 컴파일 지시자에서만 사용가능)






    