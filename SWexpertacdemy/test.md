# 알고리즘 테스트 문제 1
## 문제사항
호설이는 연말을 맞아 휴가를 끌어 모아 여행을 가려고 한다.

 

이 여행지에는 관광 도시들이 1행, 1열부터 R행 C열까지 있으며, 총 R x C 개의 도시로 이루어져 있다.

호설이는 여행 첫날엔 1행 1열의 도시로 출발한다.

각 도시에는 A부터 Z 중 하나의 알파벳으로 나타낼 수 있는 기념품이 있으며, 같은 알파벳은 같은 기념품이다.

 

호설이는 파트원들에게 나눠주기 위해 도시에 도착할 때마다 기념품을 구매할 계획이다.

그리고, 호설이는 현재 위치에서 기념품을 구매 후 4방향(동, 서, 남, 북) 중 한 방향으로 1칸 이동하여 다음 도시로 이동한다.

 

호설이는 휴가까지 아끼며 일을 했지만 모아둔 돈이 많지 않다.

따라서 기념품을 최대한 많이 구매하되, 종류가 겹치지 않도록 여행 경로를 계획하고 싶다.

 

호설이가 1행 1열에서 여행을 시작했을 때, 같은 기념품을 두 개 이상 사지 않도록 여행을 떠나는 방법 중에 가장 많은 기념품을 구매할 수 있는 최대 개수를 구하여라.

## 제한사항
* 32개 테스트케이스를 합쳐서 C/C++의 경우 10초 / Java의 경우 20초
* 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내

## 입력
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.


각 테스트 케이스의 첫 번째 줄에는 여행지의 크기 R, C(1≤R, C≤20)가 주어진다.


이어서 R개의 줄마다 C개의 알파벳 대문자가 빈 칸 없이 주어진다.
> ex)
3
2 4
CAAB
ADCB
3 6
HFDFFB
AJHGDH
DGAGEH
5 5
IEFCJ
FHFKC
FFALF
HFGCF
HMCHH



