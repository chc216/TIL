# c언어의 모든것(복습)


### 포인터 변수 : 주소를 저장하고 그 주소를 가리킬 수 있는 변수  

- int *, char *, float * 등이 포인터 자료형이다.  
--> 포인터의 메모리 크기는 모두 4byte(주소 저장을 위해), 포인터 자료형의 int, char,,,, 들은 모두 포인터가 가리키는 메모리 주소에서 몇바이트만큼을 읽어들여 해석해야하는지를 정해준다.

- 선언 시 자료형을 지정해야한다   
     --> 가리키는 주소에서 얼마만큼 읽어야하는지 모르기 때문에  
     ==> 포인터 변수가 int형이라면 p++은 주소 4만큼 증가이다.  
- 배열 이름은 배열의 시작 주소를 가리키기 때문에 포인터와 동일한 원리로 사용가능 ==> p++ == p[1] == 배열[1]  
배열 이름은 포인터 상수이다 (상수 포인터와 포인터 상수에는 엄연한 차이점이 있다.)
  

### 문자열
1.  문자열 저장법  
    * char형 배열 사용  
    > 일일이 대입 : 끝부분에 NULL문자를 수동으로 추가해야함  
    문자열 상수 사용 : 자동으로 문자열의 끝에 NULL문자 추가  
    라이브러리 함수 사용  
    * 문자형 포인터 사용
    > 문자열 상수의 주소를 대입하면 된다.  

        char *p = "hihi"; //문자형 포인터에 문자열 상수의 주소 대입

        p = "byebye"; //포인터의 주소를 변경하여 문자열 변경 가능

2. 문자열 상수  
텍스트 세그먼트라는 접근만 가능한 메모리 공간에 저장한다.  
문자형 포인터에 저장된 문자열 상수는 직접 변경 불가능함
    * (참고: 모든 변수는 데이터 세그먼트라고 불리는 메모리 영역에 저장)   

    ***(중요)컴파일러가 문자열 상수를 만나면 해당 문자열을 텍스트 세그먼트에 저장하고, 그 텍스트 세그먼트의 메모리 주소를 반환한다.


3. 문자열 배열  
문자열을 저장하기 위해선 NULL문자를 포함한 크기로 선언해야한다.



4. 문자 입출력 라이브러리 함수  
* echo : 문자를 입력하면 화면에도 출력  
 * buffer : 문자를 입력받는대로 buffer에 저장후 '\n'이 입력되면 프로그램으로 전달  

        <stdio.h>  
        int getchar(void) //하나의 문자를 읽어서 반환한다, 에코 사용, 버퍼 사용
        void putchar(int) //인수를 화면에 출력
        scanf("%c")
        printf("%c")


        <conio.h>     
        int _getch() //에코 사용하지 않음, 버퍼 사용하지 않음
        int _getch() //에코 사용, 버퍼 사용하지 않음
        void _putch(int) //인수를 화면에 출력

5. 문자 처리 라이브러리 함수  
<ctype.h>  
기본적으로 참과 거짓을 검사하는 함수이다.  
반환값은 1 또는 0으로 이루어진다.
  
6. 문자열 입출력 라이브러리 함수  


        <stdio.h>
        int scanf("%s", s) //문자열을 배열 s에 저장
        int printf("%s", s) //배열 s의 문자열을 출력(\0이 나올때까지)

        char *gets_s(char *s, int size) 
        //'\n'이 나올 때까지 문자열로 입력받는다. 줄바꿈 문자는 포함되지 않으며 끝에는 \0이 붙는다. 
        //반환값은 성공하면 인수 배열이 그대로 반환되고 실패하면 NULL값이 반환된다.

        int puts(const char *s) 
        //배열 s에 저장된 문자열 출력
        //배열 끝의 NULL문자는 \n으로 자동 변환
        //반환값은 성공하면 음수가 아닌 값이 반환되고 실패하면 EOF가 반환된다.

            <예시>
            char buff[100];
            gets_s(buff, 100);
            puts(buff);

7. 문자열 처리 라이브러리 함수  

        <string.h>

* 문자열 길이  

        strlen(s)  
    >문자열 s의 길이를 구한다 .  

* 문자열 복사  

        strcpy(s1, s2)  
    > s2가 가리키는 문자열을 s1이 가리키는 배열로 복사한다.  
    덮어씌워져서 기존의 문자열은 없어진다.  
    \0문자가 나올 때까지 복사를 계속한다.  
    복사하는 문자열의 크기보다 배열의 크기가 같거나 커야한다.

        <예시>
        char s1[10];
        char s2[10] = "hihihi";
        strcpy(s1, s2);

* 문자열 연결  

        strcat(s1, s2)  
    > s1 뒤에 문자열 s2를 붙인다. 그리고 NULL문자로 종료

* 문자열 비교  

        strcmp(s1, s2)  
    > 사전적인 순서로 두개의 문자열 비교  
    >   > s1이 s2보다 앞에 있다면    반환값<0  
    >   > s1 == s2  반환값 = 0  
    >   > s1이 s2뒤에 있으면 반환값 > 0

* 문자 n개 까지만 문자열 처리하기
    
        strncpy, strncat, strncmp(s1, s2, n)
    
    > 각각 문자 n개 까지 문자열을 처리한다.


* 문자검색  

        char *p = strchr("문자열", '문자');

    >문자열에서 발견된 문자의 주소를 반환함  
    찾지 못하면 NULL값 반환

        <예시>
        char[s] = "language";
        char c = 'g';
        char *p;
        int loc;

        p = strchr(s, c);
        log = (int)(p-s) 
        //g의 주소에서 s의 시작 주소를 뺀다 ==> g가 몇번째에 있는지 구한다.
        //배열 한칸은 1바이트이므로 p-s를 빼면 몇번째인지 나온다. (int형 배열이었다면 4byte정도 나왔을것임)
        //int 자료형 변환 이유는 출력하기 위해 정수형으로 변환한 것이다.

* 문자열 검색

        char *p = strstr("문자열", '문자');

    >문자열에서 발견된 문자열의 시작 주소를 반환함  
    찾지 못하면 NULL값 반환

    
8. 문자열 여러개 저장

* 포인터 배열 사용  

        char *p[3] = {"~~", "~~", "~~"};

    >--> 메모리 낭비를 줄이면서 문자열 여러개 저장 가능  
    >--> 텍스트 세그먼트에 저장되므로 변경 불가능

* 이차원 배열 사용

        char s[3][10] = {"~~","~~","~~"};

    > 문자형 배열에 문자열을 저장하듯이 문자열의 크기만큼 배열에 저장됨
    > 각 문자열의 마지막에는 NULL값 저장

### 구조체  


1. 기본 규칙  (파생형 자료형의 기본 규칙으로 봐도 무방)
    > 정의된 구조체 자료형은 다른 자료형과 동일하게 취급 
    >   > struct 태그 --> 하나의 자료형으로써 컴파일러는 struct 키워드를 보고 구조체임을 알고, 태그를 확인함으로써 어떤 구조체인지 확인하여 메모리 사용.  
    >   > 따라서 태그를 사용하지 않고 구조체를 정의한다면 동시에 변수도 선언을 할 수 밖에 없는 것이다.

    > 구조체 변수는 일반적인 변수와 동일하게 취급.  
    > 구조체 멤버에는 모든 자료형이 가능하다.  



### 공용체

1. 기본규칙   
    > 구조체와 규칙이 같다 .  
    메모리 할당은 멤버 중 크기가 가장 큰 멤버를 기준으로 할당된다.  
    멤버 접근은 구조체와 동일하게 (.)멤버연산자를 사용한다.  
    데이터 저장은 한번에 하나의 멤버에게만 가능하다.

2. 초기화

        union 태그명 변수명 = {~}; //첫번째 멤버에게만 값이 저장된다.  

### 열거형

1. 가독성과 의미해석이 더 수월해져 오류의 가능성이 줄어든다.
    > ex) 요일을 0~6의 숫자에 맵핑해서 사용해왔다면 열거형을 통해 기호상수로 불편함 해소


2. 사용법  
        정의

        enum days {SUN, MON, TUE, WED, THU, SAT};
        //열거형은 기호상수가 모여있는 자료형이다.
        //왼쪽부터 오른쪽으로, 0부터 1씩 증가하며, 맵핑하여 각각의 단어를 기호상수로 만들어준다.   

        enum days {SUN = 2, MON, TUE=5, WED};
        //기호상수이므로 직접 숫자를 맵핑해줄 수도 있다.
        //직접 맵핑된 기호상수 옆엔 맵핑되지 않았을 경우 자동으로 왼쪽의 것보다 +1된 것으로 간주함 (여기서 MON은 3이다.)

    열거형 변수 사용은 동일하다.


### typedef 사용자 정의 자료형

1. 사용방법

        typedef 자료형 새로운자료형;
        


        //구조체, 공용체, 열거형 정의 또한 자료형으로 간주하므로 아래와 같이 코드 구성 가능
        //태그 생략도 가능하다.

        //구조체
        typedef struct 태그{
            //멤버
        }새로운 자료형;

        //공용체
        typedef union 태그{
            //멤버
        }새로운 자료형;
        
        //열거형
        typedef enum 태그 {기호상수} 새로운 자료형;

2. 배열을 새로운 자료형으로 정의할 때

        typedef int intarray[3];
        intarray a;
        //a는 int형 3개가 들어갈 수 있는 자료형으로써 정의된다. (a[3]으로 선언된 것과 똑같다.)

3. 장점  
    1. 이식성을 높여준다.  
    2. #define 보다 좋다.  
    > #define은 전처리가 처리하므로 배열 같은 자료형은 정의하지 못한다.  
    > typedef는 컴파일러가 처리하므로 자료형 정의에 있어서 더 좋다.  
    3. 문서화의 역할도 한다.